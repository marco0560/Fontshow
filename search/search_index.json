{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Fontshow","text":"<p>Fontshow is a font inventory and catalog generation toolchain.</p>"},{"location":"#overview","title":"Overview","text":"<p>Fontshow provides:</p> <ul> <li>Cross-platform font discovery</li> <li>Deep font metadata extraction</li> <li>Script and language inference</li> <li>LaTeX catalog generation</li> </ul>"},{"location":"#documentation-structure","title":"Documentation structure","text":"<p>Use the navigation bar to explore:</p> <ul> <li>Architecture</li> <li>Data model</li> <li>Module documentation</li> </ul>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>Fontshow is a font inventory and catalog generation toolchain designed as a linear, data-driven pipeline.</p> <p>Each stage of the pipeline consumes structured data produced by the previous stage and enriches or transforms it without side effects outside its responsibility.</p> <p>At a high level, Fontshow consists of three main stages:</p> <ol> <li>Font discovery and raw metadata extraction</li> <li>Semantic inference and normalization</li> <li>Rendering and catalog generation</li> </ol> <p>The architecture intentionally avoids tight coupling between stages and relies on explicit data contracts instead of shared state.</p>"},{"location":"architecture/#design-principles","title":"Design principles","text":"<p>Fontshow follows a small set of explicit design principles:</p> <ul> <li> <p>Inventory-driven   All decisions are based on serialized inventory data.   No stage reopens or re-inspects font binaries unnecessarily.</p> </li> <li> <p>Procedural and explicit   The code favors explicit data flow over abstraction layers.</p> </li> <li> <p>Best-effort robustness   Partial failures should degrade output quality, not abort execution.</p> </li> <li> <p>Separation of concerns   Discovery, inference, and rendering are strictly separated.</p> </li> <li> <p>Reproducibility   Given the same inventory input, downstream stages produce identical   results.</p> </li> </ul>"},{"location":"architecture/#pipeline-overview","title":"Pipeline overview","text":"<p>The Fontshow pipeline is strictly linear:</p> <pre><code>Installed fonts\n      \u2502\n      \u25bc\ndump_fonts.py\n      \u2502   (raw inventory JSON)\n      \u25bc\nparse_font_inventory.py\n      \u2502   (enriched inventory JSON)\n      \u25bc\ncreate_catalog.py\n      \u2502\n      \u25bc\nLaTeX catalog\n</code></pre> <p>Each stage produces a JSON-compatible structure that can be:</p> <ul> <li>inspected manually,</li> <li>cached,</li> <li>reused independently of the other stages.</li> </ul>"},{"location":"architecture/#data-flow-and-contracts","title":"Data flow and contracts","text":"<p>The central artifact in Fontshow is the font inventory.</p> <p>The inventory is a JSON document with two main sections:</p> <ul> <li><code>metadata</code>: global information about the generation context</li> <li><code>fonts</code>: a list of per-font (or per-face) descriptors</li> </ul> <p>Each stage respects the following contract:</p> <ul> <li> <p>dump_fonts   Produces raw, low-level metadata directly extracted from font files   and system tools.</p> </li> <li> <p>parse_font_inventory   Adds semantic interpretation (scripts, languages, coverage inference)   without modifying raw fields.</p> </li> <li> <p>create_catalog   Treats the inventory as read-only input and performs rendering only.</p> </li> </ul> <p>Downstream stages must never assume the presence of optional fields unless explicitly documented.</p>"},{"location":"architecture/#module-responsibilities","title":"Module responsibilities","text":""},{"location":"architecture/#dump_fonts","title":"dump_fonts","text":"<p>Responsible for:</p> <ul> <li>discovering installed font files,</li> <li>extracting per-face metadata using fontTools,</li> <li>optional enrichment via FontConfig (Linux),</li> <li>caching expensive extraction results.</li> </ul> <p>It does not:</p> <ul> <li>perform semantic inference,</li> <li>group fonts,</li> <li>make rendering decisions.</li> </ul>"},{"location":"architecture/#parse_font_inventory","title":"parse_font_inventory","text":"<p>Responsible for:</p> <ul> <li>interpreting Unicode coverage,</li> <li>inferring scripts and languages,</li> <li>normalizing and enriching inventory entries.</li> </ul> <p>It operates purely on structured data and never accesses font binaries.</p>"},{"location":"architecture/#create_catalog","title":"create_catalog","text":"<p>Responsible for:</p> <ul> <li>grouping fonts by family,</li> <li>selecting representative samples,</li> <li>rendering LaTeX source code.</li> </ul> <p>It does not perform inference and does not alter the inventory semantics.</p>"},{"location":"architecture/#error-handling-and-robustness","title":"Error handling and robustness","text":"<p>Fontshow adopts a best-effort error handling strategy:</p> <ul> <li>errors are captured locally whenever possible,</li> <li>partial failures are represented explicitly in the data,</li> <li>the pipeline continues unless a critical invariant is violated.</li> </ul> <p>This approach ensures that:</p> <ul> <li>large font collections remain processable,</li> <li>malformed fonts do not abort the entire run,</li> <li>diagnostic information remains available for inspection.</li> </ul>"},{"location":"architecture/#why-a-procedural-architecture","title":"Why a procedural architecture","text":"<p>Fontshow intentionally avoids a class-based or object-oriented architecture.</p> <p>Reasons include:</p> <ul> <li>the pipeline is naturally linear and data-driven,</li> <li>the primary abstraction is the inventory, not behavior,</li> <li>procedural code makes data transformations explicit and traceable,</li> <li>it aligns well with batch-style processing and reproducibility.</li> </ul> <p>This choice prioritizes clarity and debuggability over extensibility through inheritance.</p>"},{"location":"architecture/#non-goals-and-future-extensions","title":"Non-goals and future extensions","text":"<p>Fontshow explicitly does not aim to:</p> <ul> <li>be a font management application,</li> <li>provide interactive UI components,</li> <li>replace existing font inspection tools.</li> </ul> <p>Possible future extensions include:</p> <ul> <li>additional output formats (HTML, PDF),</li> <li>richer statistical summaries,</li> <li>external inventory consumers.</li> </ul> <p>These extensions can be implemented without altering the core pipeline.</p>"},{"location":"create_catalog/","title":"create_catalog","text":"<p>This module generates a printable LaTeX catalog from a normalized Fontshow font inventory.</p> <p>It is the final stage of the pipeline and focuses exclusively on rendering and layout.</p>"},{"location":"create_catalog/#responsibilities","title":"Responsibilities","text":"<ul> <li>Group fonts by family</li> <li>Select representative samples</li> <li>Render LaTeX blocks</li> <li>Generate a complete XeLaTeX/LuaLaTeX document</li> </ul>"},{"location":"create_catalog/#api-reference","title":"API reference","text":""},{"location":"create_catalog/#fontshow.create_catalog","title":"fontshow.create_catalog","text":""},{"location":"create_catalog/#fontshow.create_catalog--fontshow-create_catalogpy","title":"Fontshow \u2013 create_catalog.py","text":"<p>LaTeX catalog generator for Fontshow.</p> <p>This module consumes the canonical font inventory JSON produced by <code>dump_fonts.py</code> and generates a printable LaTeX catalog.</p>"},{"location":"create_catalog/#fontshow.create_catalog--design-principles","title":"Design principles","text":"<ul> <li>Pure rendering stage: this module never inspects font binaries.</li> <li>Inventory-driven: all semantic information comes from the JSON inventory.</li> <li>Conservative defaults: missing or partial metadata is handled gracefully.</li> <li>LaTeX-first: output is optimized for XeLaTeX/LuaLaTeX workflows.</li> </ul> <p>This file intentionally mixes: - inventory glue logic, - rendering helpers, - platform-specific fallbacks, - CLI orchestration.</p> <p>The architecture is procedural by design and mirrors the historical evolution of the project.</p> <p>Pipeline for creating a LuaLaTeX font catalog from a Fontshow inventory.</p> <p>This module contains utilities for loading the JSON inventory, inferring rendering choices and producing the final LaTeX source used by the main <code>create_catalog</code> workflow. Key entrypoints: - <code>generate_latex(font_list)</code> \u2014 produce full LaTeX document - <code>get_installed_fonts()</code> \u2014 fallback discovery for legacy mode</p> <p>Keep changes minimal: the LaTeX templates in the module are whitespace- sensitive and used directly by the renderer.</p>"},{"location":"create_catalog/#fontshow.create_catalog.as_font_desc_list","title":"as_font_desc_list","text":"<pre><code>as_font_desc_list(fonts: list) -&gt; list[dict]\n</code></pre> <p>Normalize input fonts into a list of descriptors.</p> <p>If <code>fonts</code> is already a list of dicts, it is returned as-is. If <code>fonts</code> is a list of strings (legacy mode), each item becomes:     {\"identity\": {\"family\": \"\"}, \"classification\": {}, \"inference\": {}}"},{"location":"create_catalog/#fontshow.create_catalog.clean_font_name","title":"clean_font_name","text":"<pre><code>clean_font_name(name: str) -&gt; str\n</code></pre> <p>Normalize a raw font name to a family-like base name.</p> <p>Removes parenthetical hints like <code>(TrueType)</code>, and strips common variant suffixes (Bold, Italic, etc.).</p>"},{"location":"create_catalog/#fontshow.create_catalog.escape_latex","title":"escape_latex","text":"<pre><code>escape_latex(text: str) -&gt; str\n</code></pre> <p>Escape LaTeX special characters in <code>text</code>.</p> <p>Returns a string safe to embed in LaTeX source.</p>"},{"location":"create_catalog/#fontshow.create_catalog.extract_font_family","title":"extract_font_family","text":"<pre><code>extract_font_family(line)\n</code></pre> <p>Extract the family portion from a <code>fc-list</code> line.</p> <p>Example input: '/usr/share/fonts/foo.ttf:Family Name:style' Returns the family part (comma-separated families are left intact).</p>"},{"location":"create_catalog/#fontshow.create_catalog.font_family","title":"font_family","text":"<pre><code>font_family(font: dict) -&gt; str\n</code></pre> <p>Best-effort family name for LaTeX rendering and sorting.</p>"},{"location":"create_catalog/#fontshow.create_catalog.fontspec_options","title":"fontspec_options","text":"<pre><code>fontspec_options(font: dict) -&gt; str\n</code></pre> <p>Build fontspec options string.</p> <p>Uses TTC index if present, e.g.:   Index=3</p>"},{"location":"create_catalog/#fontshow.create_catalog.generate_latex","title":"generate_latex","text":"<pre><code>generate_latex(font_list: list[dict]) -&gt; str\n</code></pre> <p>Generate the full LaTeX document for the provided font descriptors.</p> <p>The input may be a list of descriptors (as produced by <code>parse_font_inventory.py</code>) or a legacy list of strings (family names).</p>"},{"location":"create_catalog/#fontshow.create_catalog.generate_test_output","title":"generate_test_output","text":"<pre><code>generate_test_output(limit: int | None = None, filter_test: bool = False) -&gt; None\n</code></pre> <p>Produce a small text file with parsing details for manual inspection.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>if positive, limit first N items; if negative, take last |N|.</p> <code>None</code> <code>filter_test</code> <code>bool</code> <p>if True, keep only fonts matching <code>TEST_FONTS</code> substrings.</p> <code>False</code>"},{"location":"create_catalog/#fontshow.create_catalog.get_font_details_linux","title":"get_font_details_linux","text":"<pre><code>get_font_details_linux() -&gt; list[dict]\n</code></pre> <p>Return diagnostic details for installed Linux fonts (for tests).</p> <p>Each item contains <code>raw_line</code>, <code>extracted_names</code> and <code>base_names</code> for easier inspection while tuning parsers.</p>"},{"location":"create_catalog/#fontshow.create_catalog.get_font_details_windows","title":"get_font_details_windows","text":"<pre><code>get_font_details_windows()\n</code></pre> <p>Return diagnostic details for installed Windows fonts (for tests).</p> <p>The returned list contains small dicts with <code>raw_line</code>, <code>extracted_names</code> and <code>base_names</code> useful for debugging parsing logic.</p>"},{"location":"create_catalog/#fontshow.create_catalog.get_installed_fonts","title":"get_installed_fonts","text":"<pre><code>get_installed_fonts() -&gt; list[str]\n</code></pre> <p>Dispatch to platform-specific font discovery.</p> <p>Returns a sorted list of family names or an empty list on unsupported OS.</p>"},{"location":"create_catalog/#fontshow.create_catalog.get_installed_fonts_linux","title":"get_installed_fonts_linux","text":"<pre><code>get_installed_fonts_linux() -&gt; list[str]\n</code></pre> <p>Return a sorted list of installed font family names on Linux using <code>fc-list</code>.</p> <p>Excluded families listed in <code>EXCLUDED_FONTS</code> are filtered out.</p>"},{"location":"create_catalog/#fontshow.create_catalog.get_installed_fonts_windows","title":"get_installed_fonts_windows","text":"<pre><code>get_installed_fonts_windows()\n</code></pre> <p>Return a sorted list of installed font family names on Windows.</p> <p>The function reads the Windows registry and normalizes names via <code>clean_font_name</code>. Excluded names from <code>EXCLUDED_FONTS</code> are filtered out.</p>"},{"location":"create_catalog/#fontshow.create_catalog.get_unique_filename","title":"get_unique_filename","text":"<pre><code>get_unique_filename(base_name, extension)\n</code></pre> <p>Genera un nome file unico aggiungendo un contatore a tre cifre (000-999).</p>"},{"location":"create_catalog/#fontshow.create_catalog.group_fonts_by_family","title":"group_fonts_by_family","text":"<pre><code>group_fonts_by_family(fonts: list[dict]) -&gt; list[dict]\n</code></pre> <p>Reduce a list of font entries to one entry per family.</p> <p>Keeps the first encountered font for each family (usually Regular or <code>ttc_index</code> 0). Preserves order of first occurrence.</p>"},{"location":"create_catalog/#fontshow.create_catalog.load_font_inventory","title":"load_font_inventory","text":"<pre><code>load_font_inventory(path: Path) -&gt; list[dict]\n</code></pre> <p>Load a Fontshow inventory JSON file.</p> Expected structure <p>{ \"fonts\": [ { ...font descriptor... }, ... ], \"metadata\": { ... } }</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>List of font descriptor dicts.</p> Notes <ul> <li>This function does not touch font files.</li> <li>It is safe to call on both Linux and Windows.</li> </ul>"},{"location":"create_catalog/#fontshow.create_catalog.nfss_family_id","title":"nfss_family_id","text":"<pre><code>nfss_family_id(font: dict) -&gt; str\n</code></pre> <p>Return a short NFSS-safe identifier for a font (used as temporary family).</p> <p>This produces a stable short id prefixed with 'FS' used in <code>fontspec</code> calls when a normalized family name is required.</p>"},{"location":"create_catalog/#fontshow.create_catalog.render_badges","title":"render_badges","text":"<pre><code>render_badges(font: dict) -&gt; str\n</code></pre> <p>Render informational badges for a font.</p> <p>Badges are ASCII-only and typeset in monospace to avoid bidi and script-direction issues. The returned string is valid LaTeX and may be empty.</p>"},{"location":"create_catalog/#fontshow.create_catalog.render_sample_code","title":"render_sample_code","text":"<pre><code>render_sample_code(font: dict, fam: str) -&gt; str\n</code></pre> <p>Build the LaTeX snippet for the sample.</p> <p>For sample rendering we MUST be conservative: - Never request Bold / Italic / BI shapes. - Never propagate weight/width/style inferred metadata. - For RTL scripts use TestNonLatin (polyglossia + harfbuzz). - For LTR scripts use a minimal, NFSS-safe fontspec call.</p>"},{"location":"data_dictionary/","title":"Data Dictionary","text":""},{"location":"data_dictionary/#overview","title":"Overview","text":"<p>This document defines the data model and contracts used throughout the Fontshow pipeline.</p> <p>The central artifact is the font inventory, a JSON-compatible structure that is progressively enriched by each pipeline stage.</p> <p>The purpose of this document is to:</p> <ul> <li>describe the structure of the inventory,</li> <li>define the meaning of each field,</li> <li>clarify which module is responsible for producing each piece of data.</li> </ul> <p>This document is normative: downstream consumers should rely on the definitions provided here.</p>"},{"location":"data_dictionary/#inventory-structure","title":"Inventory structure","text":"<p>At the top level, the font inventory is a JSON object with two main keys:</p> <ul> <li><code>metadata</code></li> <li><code>fonts</code></li> </ul> <pre><code>{\n  \"metadata\": { ... },\n  \"fonts\": [ ... ]\n}\n</code></pre>"},{"location":"data_dictionary/#global-metadata","title":"Global metadata","text":"<p>The <code>metadata</code> object contains information about the context in which the inventory was generated.</p>"},{"location":"data_dictionary/#fields","title":"Fields","text":"<ul> <li> <p><code>generator</code> (<code>string</code>)   Identifier of the tool that generated the inventory (e.g. <code>Fontshow</code>).</p> </li> <li> <p><code>version</code> (<code>string</code>)   Version of the generator.</p> </li> <li> <p><code>timestamp</code> (<code>string</code>, ISO 8601)   Generation time of the inventory.</p> </li> <li> <p><code>platform</code> (<code>string</code>)   Operating system identifier (e.g. <code>linux</code>, <code>windows</code>).</p> </li> <li> <p><code>font_count</code> (<code>integer</code>)   Total number of font faces discovered.</p> </li> </ul>"},{"location":"data_dictionary/#font-entries","title":"Font entries","text":"<p>The <code>fonts</code> array contains one entry per font face.</p> <p>Each entry is a dictionary describing a single font face extracted from a font file or a font collection.</p> <pre><code>{\n  \"file\": \"...\",\n  \"index\": 0,\n  \"family\": \"...\",\n  \"style\": \"...\",\n  \"format\": \"...\",\n  \"raw\": { ... },\n  \"coverage\": { ... },\n  \"classification\": { ... }\n}\n</code></pre> <p>Not all fields are mandatory. Optional fields may be absent if the corresponding information could not be determined.</p>"},{"location":"data_dictionary/#file-and-identity-fields","title":"File and identity fields","text":"<p>These fields identify the physical font resource.</p> <ul> <li> <p><code>file</code> (<code>string</code>)   Absolute or normalized path to the font file.</p> </li> <li> <p><code>index</code> (<code>integer</code>)   Face index within a TrueType Collection (TTC).   For single-face fonts, this is usually <code>0</code>.</p> </li> <li> <p><code>family</code> (<code>string</code>)   Font family name as reported by the font metadata.</p> </li> <li> <p><code>style</code> (<code>string</code>)   Style or subfamily name (e.g. <code>Regular</code>, <code>Bold Italic</code>).</p> </li> <li> <p><code>format</code> (<code>string</code>)   Font format identifier (e.g. <code>TTF</code>, <code>OTF</code>, <code>TTC</code>).</p> </li> </ul>"},{"location":"data_dictionary/#raw-metadata","title":"Raw metadata","text":"<p>The <code>raw</code> section contains low-level metadata extracted directly from the font binary.</p> <p>This data is produced exclusively by <code>dump_fonts</code>.</p> <p>Typical contents include:</p> <ul> <li>name table entries,</li> <li>OS/2 table fields,</li> <li>Unicode range flags,</li> <li>basic typographic metrics.</li> </ul> <p>The structure of <code>raw</code> is intentionally flexible and may vary depending on font format and available tables.</p> <p>Downstream modules must treat this section as opaque and read-only.</p>"},{"location":"data_dictionary/#coverage-information","title":"Coverage information","text":"<p>The <code>coverage</code> section describes Unicode coverage information.</p> <p>This section is initially populated by <code>dump_fonts</code> and may be refined by <code>parse_font_inventory</code>.</p> <p>Typical fields include:</p> <ul> <li>covered Unicode ranges,</li> <li>lists of representative codepoints,</li> <li>script-level coverage summaries.</li> </ul> <p>Coverage data is used as the basis for script and language inference.</p>"},{"location":"data_dictionary/#classification-and-inference","title":"Classification and inference","text":"<p>The <code>classification</code> section contains semantic information inferred from coverage and metadata.</p> <p>This section is produced by <code>parse_font_inventory</code>.</p> <p>Typical fields include:</p> <ul> <li> <p><code>scripts</code> (<code>list[string]</code>)   Writing systems supported by the font (e.g. <code>Latin</code>, <code>Cyrillic</code>).</p> </li> <li> <p><code>languages</code> (<code>list[string]</code>)   Languages likely supported by the font.</p> </li> <li> <p><code>primary_script</code> (<code>string</code>, optional)   The dominant script inferred for the font.</p> </li> <li> <p><code>confidence</code> (<code>float</code>, optional)   Confidence score associated with inference results.</p> </li> </ul> <p>Inference fields are heuristic by nature and should be interpreted as best-effort indicators rather than absolute guarantees.</p>"},{"location":"data_dictionary/#rendering-related-fields","title":"Rendering-related fields","text":"<p>Some fields are added or derived specifically to support rendering.</p> <p>These fields are typically consumed by <code>create_catalog</code> and may include:</p> <ul> <li>grouping hints,</li> <li>sample text selection metadata,</li> <li>script prioritization flags.</li> </ul> <p>Rendering-related fields must not affect upstream inference logic.</p>"},{"location":"data_dictionary/#optional-and-missing-fields","title":"Optional and missing fields","text":"<p>Fontshow is designed to tolerate incomplete data.</p> <p>Rules:</p> <ul> <li>optional fields may be missing,</li> <li>missing fields must never cause downstream crashes,</li> <li>absence of data should result in degraded output quality, not failure.</li> </ul> <p>Consumers of the inventory must always check for field presence.</p>"},{"location":"data_dictionary/#versioning-and-compatibility","title":"Versioning and compatibility","text":"<p>The inventory format is versioned implicitly via the generator version stored in <code>metadata.version</code>.</p> <p>Breaking changes to the inventory structure should be accompanied by:</p> <ul> <li>a version bump,</li> <li>explicit documentation updates,</li> <li>migration notes if applicable.</li> </ul>"},{"location":"data_dictionary/#summary","title":"Summary","text":"<p>The Fontshow data model is intentionally explicit and extensible.</p> <p>It serves as:</p> <ul> <li>a stable contract between pipeline stages,</li> <li>a serialization format for caching and inspection,</li> <li>a foundation for external tools consuming font metadata.</li> </ul>"},{"location":"dump_fonts/","title":"dump_fonts","text":"<p>This module discovers installed fonts on the host system and extracts raw, low-level metadata using fontTools and (optionally) FontConfig.</p> <p>It produces the canonical raw font inventory consumed by the rest of the Fontshow pipeline.</p>"},{"location":"dump_fonts/#responsibilities","title":"Responsibilities","text":"<ul> <li>Discover installed font files (Linux / Windows)</li> <li>Extract per-face metadata</li> <li>Handle TrueType Collections (TTC)</li> <li>Cache expensive fontTools operations</li> <li>Serialize results to JSON</li> </ul>"},{"location":"dump_fonts/#api-reference","title":"API reference","text":""},{"location":"dump_fonts/#fontshow.dump_fonts","title":"fontshow.dump_fonts","text":"<p>Fontshow - cross-platform font inventory dumper (Linux + Windows)</p> <p>This script discovers installed font files and writes a canonical JSON inventory used by the rest of Fontshow (parsing + LaTeX rendering).</p>"},{"location":"dump_fonts/#fontshow.dump_fonts--key-features","title":"Key features","text":"<ul> <li>Cross-platform discovery:</li> <li>Linux: FontConfig (fc-list)</li> <li>Windows: common font directories (Windows Fonts + user fonts)</li> <li>Deep metadata extraction via fontTools</li> <li>TrueType Collections (.ttc) are fully supported:</li> <li>each face inside a TTC becomes a separate \"font\" entry</li> <li>identity carries (file + ttc_index)</li> <li>Optional Linux-only enrichment via FontConfig (fc-query):</li> <li>scripts / languages / charset</li> <li>Persistent caching to avoid repeated decompression/decompilation</li> </ul>"},{"location":"dump_fonts/#fontshow.dump_fonts--output","title":"Output","text":"<p>A single JSON file:   {     \"metadata\": {...},     \"fonts\": [ {font descriptor}, ... ]   }</p> <p>The JSON schema is documented in: - docs/font-inventory-schema.md - docs/dump-fonts.md</p>"},{"location":"dump_fonts/#fontshow.dump_fonts.build_font_descriptor","title":"build_font_descriptor","text":"<pre><code>build_font_descriptor(font_path: Path, platform_name: str, fonttools: dict[str, Any], fontconfig: dict[str, Any] | None) -&gt; dict[str, Any]\n</code></pre> <p>Build the canonical per-font descriptor used in the JSON inventory.</p> <p>This function assembles all metadata for a single font face into a stable, JSON-serializable structure consumed by the rest of the project (parsing, inference, LaTeX rendering).</p> <p>The descriptor is intentionally verbose but normalized, so that downstream tools never need to re-open font files.</p> <p>High-level structure::</p> <pre><code>{\n  \"identity\": {...},\n  \"platform\": {...},\n  \"format\": {...},\n  \"coverage\": {...},\n  \"typography\": {...},\n  \"classification\": {...},\n  \"license\": {...},\n  \"vendor\": ...,\n  \"embedding_rights\": ...,\n  \"source\": {...}\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>font_path</code> <code>Path</code> <p>Path to the font file on disk.</p> required <code>platform_name</code> <code>str</code> <p>Normalized platform identifier (e.g. <code>\"linux\"</code>, <code>\"windows\"</code>).</p> required <code>fonttools</code> <code>dict[str, Any]</code> <p>Metadata block produced by <code>fonttools_extract_all</code> for a single face. May contain error fields.</p> required <code>fontconfig</code> <code>dict[str, Any] | None</code> <p>Optional FontConfig-derived metadata (Linux only).</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representing the canonical font descriptor.</p>"},{"location":"dump_fonts/#fontshow.dump_fonts.classify_font","title":"classify_font","text":"<pre><code>classify_font(format_block: dict[str, Any], unicode_max: int | None) -&gt; dict[str, Any]\n</code></pre> <p>Classify a font using simple, format-based heuristics.</p> <p>This classification is intentionally coarse and conservative. Richer semantic inference (scripts, languages, writing systems) is performed downstream by <code>parse_font_inventory.py</code>.</p> <p>Parameters:</p> Name Type Description Default <code>format_block</code> <code>dict[str, Any]</code> <p>Dictionary describing container and format properties (e.g. <code>container</code>, <code>font_type</code>, <code>color</code>, <code>decorative</code>, <code>variable</code>).</p> required <code>unicode_max</code> <code>int | None</code> <p>Maximum Unicode code point supported by the font, or <code>None</code> if unknown.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with boolean classification flags and format hints.</p>"},{"location":"dump_fonts/#fontshow.dump_fonts.compute_unicode_blocks","title":"compute_unicode_blocks","text":"<pre><code>compute_unicode_blocks(codepoints: set[int]) -&gt; dict[str, int]\n</code></pre> <p>Count how many code points fall into each configured Unicode block.</p> <p>Parameters:</p> Name Type Description Default <code>codepoints</code> <code>set[int]</code> <p>Set of Unicode code points present in the font cmap.</p> required <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>Mapping <code>{block_name: count}</code> containing only blocks with count &gt; 0.</p>"},{"location":"dump_fonts/#fontshow.dump_fonts.detect_color_tables","title":"detect_color_tables","text":"<pre><code>detect_color_tables(tt: TTFont) -&gt; list[str]\n</code></pre> <p>Return a list of present color-related tables (best-effort).</p>"},{"location":"dump_fonts/#fontshow.dump_fonts.detect_font_container","title":"detect_font_container","text":"<pre><code>detect_font_container(path: Path) -&gt; str\n</code></pre> <p>Detect font container by header and extension.</p> <p>Returns: \"TTF\", \"OTF\", \"TTC\", \"WOFF\", \"WOFF2\", or \"UNKNOWN\"</p>"},{"location":"dump_fonts/#fontshow.dump_fonts.extract_name_table","title":"extract_name_table","text":"<pre><code>extract_name_table(tt: TTFont) -&gt; dict[str, list[str]]\n</code></pre> <p>Extract the OpenType/TrueType name table as a JSON-friendly mapping.</p> Data structure <p>The returned dictionary maps <code>nameID</code> (string) to a list of unique values, preserving the first-seen order.</p> <p>Example::</p> <pre><code>{\n  \"1\": [\"DejaVu Sans\", \"DejaVuSans\"],\n  \"2\": [\"Book\"],\n  \"4\": [\"DejaVu Sans Book\"]\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tt</code> <code>TTFont</code> <p>An already-open <code>TTFont</code> instance (single face).</p> required <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>A mapping <code>{name_id_str: [values...]}</code>. Returns an empty dict if the</p> <code>dict[str, list[str]]</code> <p>font has no <code>name</code> table.</p>"},{"location":"dump_fonts/#fontshow.dump_fonts.extract_opentype_features","title":"extract_opentype_features","text":"<pre><code>extract_opentype_features(tt: TTFont) -&gt; list[str]\n</code></pre> <p>Best-effort extraction of GSUB/GPOS feature tags.</p>"},{"location":"dump_fonts/#fontshow.dump_fonts.extract_os2_table","title":"extract_os2_table","text":"<pre><code>extract_os2_table(tt: TTFont) -&gt; dict[str, Any]\n</code></pre> <p>Extract a small subset of OS/2 fields, best-effort.</p> <p>The OS/2 table is frequently present but can be malformed. This function therefore uses defensive attribute access and returns only a stable subset.</p> <p>Extracted keys (when available): - <code>weight_class</code> (int) - <code>width_class</code> (int) - <code>embedding_rights</code> (int) - <code>vendor_id</code> (str, normalized to ASCII where possible) - <code>version</code> (int)</p> <p>Parameters:</p> Name Type Description Default <code>tt</code> <code>TTFont</code> <p>An already-open <code>TTFont</code> instance (single face).</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with the extracted keys, or an empty dict if no OS/2 table</p> <code>dict[str, Any]</code> <p>is present.</p>"},{"location":"dump_fonts/#fontshow.dump_fonts.extract_unicode_coverage","title":"extract_unicode_coverage","text":"<pre><code>extract_unicode_coverage(tt: TTFont, limit: int = 200000) -&gt; dict[str, Any]\n</code></pre> <p>Compute a lightweight Unicode coverage summary from cmap.</p> <p>To keep inventories reasonably small, this function does not store the full cmap/codepoint list. Instead it stores:</p> <ul> <li><code>count</code>: number of distinct code points observed (capped by <code>limit</code>)</li> <li><code>min</code>: minimum code point or <code>None</code></li> <li><code>max</code>: maximum code point or <code>None</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>tt</code> <code>TTFont</code> <p>An already-open <code>TTFont</code> instance (single face).</p> required <code>limit</code> <code>int</code> <p>Maximum number of distinct code points to collect before stopping.</p> <code>200000</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with keys <code>count</code>, <code>min</code>, <code>max</code>.</p> <code>dict[str, Any]</code> <p>If no cmap exists, returns an empty dict.</p>"},{"location":"dump_fonts/#fontshow.dump_fonts.fc_query_extract","title":"fc_query_extract","text":"<pre><code>fc_query_extract(path: Path, include_charset: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Extract a limited set of FontConfig-derived metadata (Linux only).</p> <p>This function invokes <code>fc-query</code> and parses a small, stable subset of its output, suitable for inclusion in the Fontshow inventory.</p> <p>Important notes: - The extraction is file-level, not face-level. - For TTC files, FontConfig may describe multiple faces together;   per-face script/language inference is intentionally deferred to   <code>parse_font_inventory.py</code>. - All fields are optional and best-effort.</p> <p>Extracted fields: - <code>languages</code>: list of BCP-47-like language tags. - <code>scripts</code>: OpenType script tags derived from <code>otlayout</code> capability. - <code>charset</code>: raw FontConfig charset blob (optional, Linux only). - <code>decorative</code>: whether the font is marked decorative. - <code>color</code>: whether the font is marked as color. - <code>variable</code>: whether the font is marked variable.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the font file.</p> required <code>include_charset</code> <code>bool</code> <p>If <code>True</code>, include the raw FontConfig charset blob. This can be large and is disabled by default.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with zero or more of the keys described above.</p>"},{"location":"dump_fonts/#fontshow.dump_fonts.font_cache_key","title":"font_cache_key","text":"<pre><code>font_cache_key(path: Path, ttc_index: int | None = None) -&gt; str\n</code></pre> <p>Return a stable cache key for a font face.</p> <p>The cache key uniquely identifies a specific font face by combining: - the absolute file path, - file modification time (nanoseconds), - file size, - optional TTC face index.</p> <p>This guarantees that cache entries are invalidated whenever the font file changes on disk, while still allowing efficient reuse across runs.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the font file.</p> required <code>ttc_index</code> <code>int | None</code> <p>Face index for TrueType Collections (<code>None</code> for single-face fonts).</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A SHA-256 hexadecimal digest suitable for use as a filename.</p>"},{"location":"dump_fonts/#fontshow.dump_fonts.fonttools_extract_all","title":"fonttools_extract_all","text":"<pre><code>fonttools_extract_all(path: Path, cache_dir: Path, use_cache: bool = True) -&gt; list[dict[str, Any]]\n</code></pre> <p>Extract fontTools metadata for one file, returning one entry per face.</p> <p>Behavior: - For single-face formats, returns a one-element list. - For TTC files, returns one element per face (with <code>ttc_index</code> set). - If <code>fontTools</code> is unavailable, returns a single error block.</p> Caching <p>Per-face JSON blocks are cached in <code>cache_dir</code> using :func:<code>font_cache_key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Font file path.</p> required <code>cache_dir</code> <code>Path</code> <p>Directory used for per-face JSON cache files.</p> required <code>use_cache</code> <code>bool</code> <p>If <code>True</code>, reuse cached JSON blocks where possible.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>A list of dictionaries, each describing a single face.</p>"},{"location":"dump_fonts/#fontshow.dump_fonts.get_installed_font_files_linux","title":"get_installed_font_files_linux","text":"<pre><code>get_installed_font_files_linux() -&gt; list[Path]\n</code></pre> <p>Linux font discovery using FontConfig (fc-list).</p>"},{"location":"dump_fonts/#fontshow.dump_fonts.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>CLI entry point for font inventory generation.</p> <p>This function orchestrates the full dump pipeline:</p> <ol> <li>Discover installed font files for the current platform.</li> <li>Extract per-face metadata using <code>fontTools</code>.</li> <li>Optionally enrich metadata using FontConfig (Linux only).</li> <li>Build canonical font descriptors.</li> <li>Write the resulting JSON inventory to disk.</li> </ol> <p>All heavy lifting is delegated to dedicated helpers; this function is intentionally linear and side-effect driven (filesystem I/O).</p>"},{"location":"parse_font_inventory/","title":"parse_font_inventory","text":"<p>This module enriches the raw font inventory produced by <code>dump_fonts</code> by performing script, language, and writing-system inference.</p> <p>It operates purely on JSON data and never inspects font binaries.</p>"},{"location":"parse_font_inventory/#responsibilities","title":"Responsibilities","text":"<ul> <li>Infer primary script(s)</li> <li>Infer language coverage</li> <li>Normalize Unicode coverage information</li> <li>Attach inference metadata to each font entry</li> </ul>"},{"location":"parse_font_inventory/#api-reference","title":"API reference","text":""},{"location":"parse_font_inventory/#fontshow.parse_font_inventory","title":"fontshow.parse_font_inventory","text":""},{"location":"parse_font_inventory/#fontshow.parse_font_inventory--fontshow-parse_font_inventorypy","title":"Fontshow \u2013 parse_font_inventory.py","text":"<p>Parse and enrich a <code>font_inventory.json</code> produced by <code>dump_fonts.py</code> by applying deterministic inference of writing scripts and language candidates.</p>"},{"location":"parse_font_inventory/#fontshow.parse_font_inventory--design-principles","title":"Design principles","text":"<ul> <li>Cross-platform: works only on JSON data, never touches font files.</li> <li>Deterministic: same input \u2192 same output.</li> <li>Non-destructive: declared metadata is never overwritten.</li> <li>Configurable: inference aggressiveness selectable from CLI.</li> </ul> <p>Default inference level: <code>medium</code>.</p>"},{"location":"parse_font_inventory/#fontshow.parse_font_inventory.infer_languages","title":"infer_languages","text":"<pre><code>infer_languages(scripts: list[str]) -&gt; list[str]\n</code></pre> <p>Infer plausible language codes from inferred scripts.</p> <p>Parameters:</p> Name Type Description Default <code>scripts</code> <code>list[str]</code> <p>List of script identifiers as returned by :func:<code>infer_scripts</code>.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A sorted list of unique language codes.</p>"},{"location":"parse_font_inventory/#fontshow.parse_font_inventory.infer_scripts","title":"infer_scripts","text":"<pre><code>infer_scripts(coverage: dict[str, Any], level: str = 'medium') -&gt; list[str]\n</code></pre> <p>Infer writing scripts from Unicode coverage metadata.</p> <p>The function follows a two-step strategy:</p> <ol> <li>Primary path: analyze <code>coverage[\"unicode_blocks\"]</code> if present.</li> <li>Fallback path: infer from <code>coverage[\"unicode\"][\"max\"]</code>.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>coverage</code> <code>dict[str, Any]</code> <p>Coverage block extracted from a font entry. Expected keys are <code>unicode_blocks</code> (mapping block name \u2192 count) and/or <code>unicode.max</code> (maximum code point).</p> required <code>level</code> <code>str</code> <p>Inference aggressiveness level. One of <code>\"conservative\"</code>, <code>\"medium\"</code> (default), or <code>\"aggressive\"</code>.</p> <code>'medium'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of inferred script identifiers (lowercase strings).</p> <code>list[str]</code> <p>Returns <code>[\"unknown\"]</code> if no reliable inference is possible.</p>"},{"location":"parse_font_inventory/#fontshow.parse_font_inventory.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>CLI entry point.</p>"},{"location":"parse_font_inventory/#fontshow.parse_font_inventory.parse_inventory","title":"parse_inventory","text":"<pre><code>parse_inventory(data: dict[str, Any], level: str) -&gt; dict[str, Any]\n</code></pre> <p>Enrich a font inventory with deterministic inference results.</p> <p>The function iterates over <code>data[\"fonts\"]</code> and adds an <code>inference</code> block to each font entry.</p> <p>Added structure::</p> <pre><code>font[\"inference\"] = {\n    \"level\": str,\n    \"scripts\": list[str],\n    \"languages\": list[str],\n    \"declared_scripts\": list[str],\n    \"declared_languages\": list[str],\n    \"unicode_blocks\": dict[str, int],\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Parsed JSON inventory as a Python dictionary.</p> required <code>level</code> <code>str</code> <p>Inference aggressiveness level.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The same inventory dictionary, enriched in place.</p>"}]}